#include "Include/Application.h"

#include <Library/MemoryAllocationLib.h>


EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t* fileSize);

void memcpy_usr(void* dest, const void* src, size_t n) {
	char *src_char = (char *)src;
	char *dest_char = (char *)dest;
	for (int i=0; i<n; i++) {
		dest_char[i] = src_char[i]; //copy contents byte by byte
	}
}


#define _MEM(addr) *(volatile uint32_t *)(addr)
#define mem_read(addr) _MEM(addr)
#define mem_write(addr, value) _MEM(addr) = value
#define mem_clear(base, value) _R_MEMEG(addr) &= ~value
#define mem_set(base, value) _RE_MEMG(addr) |= value

EFI_STATUS PayloadLoaderEntryPoint(
		EFI_HANDLE 		ImageHandle,
		EFI_SYSTEM_TABLE 	*SystemTable
	)
{
	EFI_STATUS Status = EFI_SUCCESS;

	// Turn off watchdog timer, since this does take a while
	Print(L"Disable Watchdog\n");
	gBS->SetWatchdogTimer(0, 0, 0, NULL);

	// Fix Surface RT UEFI on-screen console
	Print(L"Fixing T30 Console. You can't see me ;)\n");
	Tegra3ConsoleOutputFixup();
	Print(L"Welcome to the Payload Loader\n");
//	uart_print("UEFI: Payload Loader\r\n");

	// Unprotect Trustzone
	Print(L"\tUnprotect TZ\n");
//	uart_print("Unprotect TZ\r\n");

	SurfaceRTExploit();

//	uart_print("done exploit\r\n");
	Print(L"done exploit\n");

	// Load exploit payload into memory
	Print(L"Loading exploit payload into memory!\n");
//	uart_print("Loading exploit payload into memory!\r\n");

	size_t ram_fileSize = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x89000000, L"\\ramdisk.img", &ram_fileSize);

	size_t rec_ram_fileSize = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x92000000, L"\\recovery-ramdisk.img", &rec_ram_fileSize);
	
	size_t fileSize1 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83000000, L"\\s2_payload.bin", &fileSize1);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading payload!\n");
//		uart_print("Failed at loading payload!\r\n");
		FinalizeApp();
	}
	Print(L"\tPayload is now in memory!\n");
//	uart_print("Payload is now in memory!\r\n");

	// Put uboot into memory
	Print(L"Loading u-boot into memory!\n");
//	uart_print("Loading u-boot into memory!\r\n");
	size_t fileSize2 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x84000000, L"\\u-boot-dtb-s2.bin", &fileSize2);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading u-boot!\n");
//		uart_print("Failed at loading u-boot!\r\n");
		FinalizeApp();
	}
	Print(L"\tU-boot is now in memory!\n");
//	uart_print("U-boot is now in memory!\r\n");
Print(L"                                       .....'',;;::cccllllllllllllcccc:::;;,,,''...'',,'..\n");
Print(L"                            ..';cldkO00KXNNNNXXXKK000OOkkkkkxxxxxddoooddddddxxxxkkkkOO0XXKx:.\n");
Print(L"                      .':ok0KXXXNXK0kxolc:;;,,,,,,,,,,,;;,,,''''''',,''..              .'lOXKd'\n");
Print(L"                 .,lx00Oxl:,'............''''''...................    ...,;;'.             .oKXd.\n");
Print(L"              .ckKKkc'...'',:::;,'.........'',;;::::;,'..........'',;;;,'.. .';;'.           'kNKc.\n");
Print(L"           .:kXXk:.    ..       ..................          .............,:c:'...;:'.         .dNNx.\n");
Print(L"          :0NKd,          .....''',,,,''..               ',...........',,,'',,::,...,,.        .dNNx.\n");
Print(L"         .xXd.         .:;'..         ..,'             .;,.               ...,,'';;'. ...       .oNNo\n");
Print(L"         .0K.         .;.              ;'              ';                      .'...'.           .oXX:\n");
Print(L"       .oNO.         .                 ,.              .     ..',::ccc:;,..     ..                lXX:\n");
Print(L"       .dNX:               ......       ;.                'cxOKK0OXWWWWWWWNX0kc.                    :KXd.\n");
Print(L"     .l0N0;             ;d0KKKKKXK0ko:...              .l0X0xc,...lXWWWWWWWWKO0Kx'                   ,ONKo.\n");
Print(L"   .lKNKl...'......'. .dXWN0kkk0NWWWWWN0o.            :KN0;.  .,cokXWWNNNNWNKkxONK: .,:c:.      .';;;;:lk0XXx;\n");
Print(L"  :KN0l';ll:'.         .,:lodxxkO00KXNWWWX000k.       oXNx;:okKX0kdl:::;'',;coxkkd, ...'. ...'''.......',:lxKO:.\n");
Print(L"oNNk,;c,'',.                      ...;xNNOc,.         ,d0X0xc,.     .dOd,           ..;dOKXK00000Ox:.   ..''dKO,\n");
Print(L"'KW0,:,.,:..,oxkkkdl;'.                'KK'              ..           .dXX0o:'....,:oOXNN0d;.'. ..,lOKd.   .. ;KXl.\n");
Print(L";XNd,;  ;. l00kxoooxKXKx:..ld:         ;KK'                             .:dkO000000Okxl;.   c0;      :KK;   .  ;XXc\n");
Print(L"'XXdc.  :. ..    '' 'kNNNKKKk,      .,dKNO.                                   ....       .'c0NO'      :X0.  ,.  xN0.\n");
Print(L".kNOc'  ,.      .00. ..''...      .l0X0d;.             'dOkxo;...                    .;okKXK0KNXx;.   .0X:  ,.  lNX'\n");
Print(L",KKdl  .c,    .dNK,            .;xXWKc.                .;:coOXO,,'.......       .,lx0XXOo;...oNWNXKk:.'KX;  '   dNX.\n");
Print(L"  :XXkc'....  .dNWXl        .';l0NXNKl.          ,lxkkkxo' .cK0.          ..;lx0XNX0xc.     ,0Nx'.','.kXo  .,  ,KNx.\n");
Print(L"   cXXd,,;:, .oXWNNKo'    .'..  .'.'dKk;        .cooollox;.xXXl     ..,cdOKXXX00NXc.      'oKWK'     ;k:  .l. ,0Nk.\n");
Print(L"    cXNx.  . ,KWX0NNNXOl'.           .o0Ooldk;            .:c;.':lxOKKK0xo:,.. ;XX:   .,lOXWWXd.      . .':,.lKXd.\n");
Print(L"     lXNo    cXWWWXooNWNXKko;'..       .lk0x;       ...,:ldk0KXNNOo:,..       ,OWNOxO0KXXNWNO,        ....'l0Xk,\n");
Print(L"     .dNK.   oNWWNo.cXK;;oOXNNXK0kxdolllllooooddxk00KKKK0kdoc:c0No        .'ckXWWWNXkc,;kNKl.          .,kXXk,\n");
Print(L"      'KXc  .dNWWX;.xNk.  .kNO::lodxkOXWN0OkxdlcxNKl,..        oN0'..,:ox0XNWWNNWXo.  ,ONO'           .o0Xk;\n");
Print(L"      .ONo    oNWWN0xXWK, .oNKc       .ONx.      ;X0.          .:XNKKNNWWWWNKkl;kNk. .cKXo.           .ON0;\n");
Print(L"      .xNd   cNWWWWWWWWKOkKNXxl:,'...;0Xo'.....'lXK;...',:lxk0KNWWWWNNKOd:..   lXKclON0:            .xNk.\n");
Print(L"      .dXd   ;XWWWWWWWWWWWWWWWWWWNNNNNWWNNNNNNNNNWWNNNNNNWWWWWNXKNNk;..        .dNWWXd.             cXO.\n");
Print(L"      .xXo   .ONWNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNK0ko:'..OXo          'l0NXx,              :KK,\n");
Print(L"      .OXc    :XNk0NWXKNWWWWWWWWWWWWWWWWWWWWWNNNX00NNx:'..       lXKc.     'lONN0l.              .oXK:\n");
Print(L"      .KX;    .dNKoON0;lXNkcld0NXo::cd0NNO:;,,'.. .0Xc            lXXo..'l0NNKd,.              .c0Nk,\n");
Print(L"      :XK.     .xNX0NKc.cXXl  ;KXl    .dN0.       .0No            .xNXOKNXOo,.               .l0Xk;.\n");
Print(L"     .dXk.      .lKWN0d::OWK;  lXXc    .OX:       .ONx.     . .,cdk0XNXOd;.   .'''....;c:'..;xKXx,\n");
Print(L"     .0No         .:dOKNNNWNKOxkXWXo:,,;ONk;,,,,,;c0NXOxxkO0XXNXKOdc,.  ..;::,...;lol;..:xKXOl.\n");
Print(L"     ,XX:             ..';cldxkOO0KKKXXXXXXXXXXKKKKK00Okxdol:;'..   .';::,..':llc,..'lkKXkc.\n");
Print(L"     :NX'    .     ''            ..................             .,;:;,',;ccc;'..'lkKX0d;.\n");
Print(L"     lNK.   .;      ,lc,.         ................        ..,,;;;;;;:::,....,lkKX0d:.\n");
Print(L"    .oN0.    .'.      .;ccc;,'....              ....'',;;;;;;;;;;'..   .;oOXX0d:.\n");
Print(L"    .dN0.      .;;,..       ....                ..''''''''....     .:dOKKko;.\n");
Print(L"     lNK'         ..,;::;;,'.........................           .;d0X0kc'.\n");
Print(L"     .xXO'                                                 .;oOK0x:.\n");
Print(L"      .cKKo.                                    .,:oxkkkxk0K0xc'.\n");
Print(L"        .oKKkc,.                         .';cok0XNNNX0Oxoc,.\n");
Print(L"          .;d0XX0kdlc:;,,,',,,;;:clodkO0KK0Okdl:,'..\n");
Print(L"              .,coxO0KXXXXXXXKK0OOxdoc:,..\n");
	// Disable MMU to get access to Trustzone memory by disarming the Translation Table / Page Table
	// NO UEFI FROM HERE: Print(), ..., and so on
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();
//	uart_print("UEFI: MMU disbaled\r\n");

	// Copy payload into Trustzone memory.
	// 0x80112174 is in the SMC handler, right after the Synchronization barriers
	// The memory needs to be marked as secure, as you can only execute secure memory in secure mode so
	// we copy the payload to TZ memory

	memcpy_usr((void*)(0x80119F74), (const void*)0x83000000, (size_t)fileSize1);

	// Redirect Core 1 SMC handler to the secure payload location
	// Could be done with MMU enabled
	// Since the copy with MMU disabled often fails it might be better to do it outside?
//	mem_write(0x82002880U, 0x83100000U);

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

//	Print(L"I just wrote Trustzone and I'm still alive!\r\n");
//	uart_print("I just wrote Trustzone and I'm still alive!\r\n");

	// Say goodbye to UEFI.
//	Print(L"\tUEFI part finished. Setting up for SMC.\n");
//	uart_print("UEFI part finished. Setting up for SMC.\n");
	Print(L"\tIf U-Boot does not immediately load, HOLD DOWN POWER TO TURN OFF\n");
//	uart_print("See you soon\r\n");

//	mem_write(0x88000000, 0);

//	start_secondary_core(1);

	// EXIT BOOT SERVICE AS TEST
	UINTN MemMapSize = 0;
	EFI_MEMORY_DESCRIPTOR* MemMap = 0;
	UINTN MapKey = 0;
	UINTN DesSize = 0;
	UINT32 DesVersion = 0;

	// May pass some parameters if needed?
	gBS->GetMemoryMap(
                &MemMapSize,
                MemMap,
                &MapKey,
                &DesSize,
                &DesVersion
        );

        /* Shutdown */
        Status = gBS->ExitBootServices(
              ImageHandle,
                MapKey
        );

        if (EFI_ERROR(Status))
        {
                Print(L"Failed to exit BS\n");
  //              uart_print("BootService NOT gone ;(\r\n");
       }
	// EXIT BOOT SERVICE AS TEST

//	while(1);

	// This should trigger an SMC, jump to the payload and output stuff to uart. Hopefully.
	ArmCallSmcHelper(0, 0, 0, 0);

	// We shouldn't get here since going back from the SMC in the payload isn't implemented and probably won't.
	Print(L"Something went wrong, we shouldn't be here\n");
//	uart_print("Something went wrong, we shouldn't be here\r\n");

	// We already messed with UEFI so we can't continue normally.
	FinalizeApp();
	return Status;
}

VOID FinalizeApp(VOID)
{
//	// Let people wait for stroke
//	uart_print("!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
//	uart_print("!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
//	uart_print("!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
	Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
	Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
	Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
	CpuDeadLoop();
}

EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t* fileSize)
{
	EFI_LOADED_IMAGE *loaded_image = NULL;
	EFI_GUID loaded_image_protocol = LOADED_IMAGE_PROTOCOL;
	EFI_STATUS status;
	EFI_GUID sfspGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = NULL;

	status = gBS->HandleProtocol(
		gImageHandle,
		&loaded_image_protocol,
		(void **) &loaded_image);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 1st HandleProtocol\n");
		return status;
	}

	status = gBS->HandleProtocol(
		loaded_image->DeviceHandle,
		&sfspGuid,
		(void**)&fs);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 2nd HandleProtocol\n");
		return status;
	}

	EFI_FILE_PROTOCOL* fileProtocol = NULL;

	status = fs->OpenVolume(fs, &fileProtocol);
	EFI_FILE_PROTOCOL* file = NULL;

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at OpenVolume!\n");
		return status;
	}

	status = fileProtocol->Open(
			fileProtocol,
			&file,
			fileName,
			EFI_FILE_MODE_READ,
			EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at opening file!\n");
		return status;
	}

	EFI_FILE_INFO *payloadFileInformation = NULL;
	UINTN payloadFileInformationSize = 0;

	status = file->GetInfo(
			file,
			&gEfiFileInfoGuid,
			&payloadFileInformationSize,
			(VOID *) payloadFileInformation);

	if (status != EFI_SUCCESS && status != EFI_BUFFER_TOO_SMALL)
	{
		Print(L"Failed at getting file info! (1)\n");
		return status;
	}

	status = gBS->AllocatePool(
		EfiLoaderData,
		payloadFileInformationSize,
		(void**)&payloadFileInformation);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at allocating pool!\n");
		return status;
	}

	SetMem(
		(VOID *)payloadFileInformation,
		payloadFileInformationSize,
		0xFF);

	status = file->GetInfo(
		file,
		&gEfiFileInfoGuid,
		&payloadFileInformationSize,
		(VOID *)payloadFileInformation
	);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at getting file info! (2)\n");
		return status;
	}

//	uart_print("memoryAddress: %016lx\r\n", memoryAddress);
	EFI_PHYSICAL_ADDRESS payloadFileBuffer = memoryAddress;
//	uart_print("payloadFileBuffer: %016lx\r\n", payloadFileBuffer);

	UINTN payloadFileSize = payloadFileInformation->FileSize;

	Print(L"Payloadsize: %u\n", payloadFileSize);

	UINTN Pages = EFI_SIZE_TO_PAGES (payloadFileSize);
	status = gBS->AllocatePages(AllocateAddress, EfiLoaderData, Pages, &payloadFileBuffer);

	if (status != EFI_SUCCESS)
	{
		switch (status)
		{
		case EFI_OUT_OF_RESOURCES:
//			uart_print("EFI_OUT_OF_RESOURCES\r\n");
			break;
		case EFI_INVALID_PARAMETER:
//			uart_print("EFI_INVALID_PARAMETER\r\n");
			break;
		case EFI_NOT_FOUND:
//			uart_print("EFI_NOT_FOUND\r\n");
			break;
		default:
			break;
		}

		Print(L"Failed at AllocatePages!\n");
//		uart_print("Failed at AllocatePages!\r\n");
		return status;
	}

	SetMem(
		(EFI_PHYSICAL_ADDRESS*)payloadFileBuffer,
		payloadFileSize,
		0xFF);

	status = file->Read(
		file,
		&payloadFileSize,
		(EFI_PHYSICAL_ADDRESS*)payloadFileBuffer
	);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at reading file into memory!\n");
		return status;
	}

	*fileSize = payloadFileSize;

	Print(L"File is now in memory at location 0x%08lx!\n", payloadFileBuffer);


	//uart_print("Printing the 1st 4 bytes at 0x84000000: %08x\r\n", *((uint32_t*)(0x84000000)));

	return EFI_SUCCESS;
}
