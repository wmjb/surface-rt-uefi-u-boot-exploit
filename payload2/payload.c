#include <stdint.h>
#include "system_regs.h"
#include "tegra30_uart.h"
#include "printf.h"
#include "mmu_dump.h"
#include "stddef.h"

#define _MEM(addr) *(volatile uint32_t *)(addr)
#define mem_read(addr) _MEM(addr)
#define mem_write(addr, value) _MEM(addr) = value
#define mem_clear(base, value) _R_MEMEG(addr) &= ~value
#define mem_set(base, value) _RE_MEMG(addr) |= value

//typedef UINTN size_t;
//typedef UINT8 uint8_t;
//typedef UINT16 uint16_t;
//typedef UINT32 uint32_t;
//typedef UINT64 uint64_t;

void memcpy_usr(void* dest, const void* src, size_t n);

void main()
{
	// Check if Security Related Registers can be written

	// CP15SDISABLE & CFGSDISABLE
	*((uint32_t*)0x6000C208) |= (0 << 4) | (0 << 5);


//	MC_SMMU_CONFIG_0 = h10
//	MC 7000:f000
	*((uint32_t*)0x7000f010) = 0;


//disable_mmu();

//	clear_ns();


	disable_mmu();

//	mem_write(0x811f8000, 0x83000000U); // set core 0 smc handler address to payload

	printf("secondary about to die\r\n");

uint32_t *ID_base = (uint32_t*)0x50041080;
printf("ID BASE 0 = %lx\r\n",ID_base[0]);
printf("ID BASE 1 = %lx\r\n",ID_base[1]);

//clear_ns();
//ID_base[0]=0;
//ID_base[1]=0;
//ID_base[2]=0;


//printf("ID BASE 0 = %lx\n",ID_base[0]);
//printf("ID BASE 1 = %lx\n",ID_base[1]);


//void (*uboot)(void)=(void(*)())0x84000000U;
//uboot();

memcpy_usr((void*)(0x80112174), (const void*)0x83000000, (size_t)25000);

	//mem_write(0x811f8000, 0x83000000U); // set core 0 smc handler address to payload

uint32_t *tz_mvbar = (uint32_t*)0x811f8020;

printf("tz_mvbar contents = %lx\r\n",tz_mvbar[0]);

//*((uint32_t*)0x50040100) = 0x1E0;
	
//	mem_write(0x811f8020, 0x80110000U); // set core 0 smc handler address to payload
clear_ns();
	*((uint32_t*)0x88002000) = 2;

//uint32_t *tz_mvbar = (uint32_t*)0x811f8000;

printf("tz_mvbar contents = %lx\r\n",tz_mvbar[0]);

	do{}while(1);
}

void memcpy_usr(void* dest, const void* src, size_t n) {
	//cast src and dest to char*
	char *src_char = (char *)src;
	char *dest_char = (char *)dest;
	for (int i=0; i<n; i++) {
		dest_char[i] = src_char[i]; //copy contents byte by byte
	}
}
